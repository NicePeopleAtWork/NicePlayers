package com.theplatform.pdk.plugins.overlay {	import com.theplatform.pdk.controllers.IPlayerController;	import com.theplatform.pdk.data.CategoryInfo;	import com.theplatform.pdk.data.Clip;	import com.theplatform.pdk.data.LoadObject;	import com.theplatform.pdk.data.Padding;	import com.theplatform.pdk.data.Release;	import com.theplatform.pdk.data.TimeObject;	import com.theplatform.pdk.events.PdkEvent;	import com.theplatform.pdk.events.PlayerEvent;	import com.theplatform.pdk.plugins.IPlugIn;	import com.theplatform.pdk.utils.Debug;	import com.theplatform.pdk.utils.PdkStringUtils;		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.text.TextFormat;		public class SamplePlugin extends Sprite implements IPlugIn	{		private var _lo:LoadObject;		private var _controller:IPlayerController;		private var _welcome:String;		private var _bitrate:int = 0;		private var _isPaused:Boolean = false;		private var _clip:Clip;		private var _toResize:Boolean = true;//keeps the media from being resized 3 times a second				private var _playerRect:Rectangle = new Rectangle();				public var subPlugin:Object;				public function SamplePlugin()		{			// Do any necessarily constructor logic here.  Note that when the plug-in is			// actually loaded, "initialize" below will be called, so typically all set-up			// logic will be in the "initialize" function		}				public function initialize(lo:LoadObject):void		{			_lo = lo;			// The LoadObject contains a reference to the controller.			_controller = _lo.controller as IPlayerController;			// Use the vars property of the LoadObject to 			// collect the FlashVars from the canvas. 			_welcome = _lo.vars["welcome"];			// Add your listener methods to the controller.			_controller.addEventListener(PdkEvent.OnPlugInsComplete, loadComplete);			_controller.addEventListener(PdkEvent.OnMediaPlaying, mediaPlaying);			_controller.addEventListener(PlayerEvent.OnOverlayAreaChanged, overlayAreaChanged);			_controller.addEventListener(PdkEvent.OnReleaseEnd, releaseEnd);			_controller.addEventListener(PdkEvent.OnMediaPause, onPause);			_controller.addEventListener(PdkEvent.OnMediaUnpause, onUnpause);			_controller.addEventListener(PdkEvent.OnMediaStart, onMediaStart);			_controller.addEventListener(PdkEvent.OnLoadRelease, onLoadRelease);			_controller.addEventListener(PdkEvent.OnLoadReleaseUrl, onLoadRelease);			_controller.addEventListener(PdkEvent.OnStreamSwitched, onStreamSwitched);			_controller.addEventListener(PlayerEvent.OnNetConnectionStatus, onNetConnectionStatus);			_controller.addEventListener(PdkEvent.OnSkinComplete, onSkinComplete);						// You can add traces to your plug-ins.  These traces will be sent			// to LogBook.  Note that any traces at a log level below the "logLevel"			// configured for the parent component won't be sent.			_controller.trace("Initialized plug-in with welcome=[" + _welcome + "]", "SamplePlugIn", Debug.INFO);		}				private function onNetConnectionStatus(e:PlayerEvent):void {			var info:Object = e.data;			_controller.trace("onNetStatus: " + info.code + " " + info.level, "SamplePlugIn", Debug.INFO);		}				//all of the possible plugins have loaded		private function loadComplete(e:PdkEvent):void		{			_controller.trace("Received OnPlugInsComplete", "SamplePlugIn", Debug.INFO);						// It's a good idea to remove event listeners and delegates when they aren't needed any more			_controller.removeEventListener(PdkEvent.OnPlugInsComplete, loadComplete);								// Now that the loading is complete, we can access the subPlugin via the LoadObject.			// This isn't available at initialize, only after loadComplete can we be sure it's there.			// If your plug-in doesn't need to load a supporting SWF, you can skip this step.			subPlugin = _lo.subPlugInRef;						// Warning! if the subPlugin isn't included in the flashvars, we'll throw an error here			// put in some error catching code if the subplugin is integral to the operation of the plugin						if (!subPlugin)			{				_controller.trace("subPlugin did not load", "SamplePlugIn", Debug.ERROR);//				_controller.removeEventListener(PdkEvent.OnMediaPlaying, mediaPlaying);//				_controller.removeEventListener(PlayerEvent.OnOverlayAreaChanged, overlayAreaChanged);//				_controller.removeEventListener(PdkEvent.OnReleaseEnd, releaseEnd);//				_controller.removeEventListener(PdkEvent.OnMediaPause, onPause);//				_controller.removeEventListener(PdkEvent.OnMediaUnpause, onUnpause);//				_controller.removeEventListener(PdkEvent.OnMediaStart, onMediaStart);					//				_controller.removeEventListener(PdkEvent.OnLoadRelease, onLoadRelease);					//				_controller.removeEventListener(PdkEvent.OnLoadReleaseUrl, onLoadRelease);//				_controller.removeEventListener(PdkEvent.OnStreamSwitched, onStreamSwitched);									return;			}						// Add the subPlugin with the overlay content to this Sprite.			addChild(subPlugin as DisplayObject);						// Send a reference to this instance to the subPlugin 			// so it can use this object as a means to send messages to the controller. 			// Other means of communication between the subPlugin and plugin like status checks			// are OK, too, we just want to avoid calling the controller directly from the subPlugin.			subPlugin.setWrapper(this);		}		private function onSkinComplete(e:PdkEvent):void		{			// Try to grab the preferred font from the skin. 			var tf:TextFormat = _controller.getTextFormat("CategoryListItemFont");			//  getTextFormat returns null if the font symbol doesn't exist in the skin.			if (tf != null) subPlugin.setTF(tf);						// Write the sample text into the overlay. 			if (_welcome) subPlugin.write(_welcome);						// Size and center the subPlugin.			centerPlugin(false, _controller.getOverlayArea());		}				// This event fires when a release is loaded		private function onLoadRelease(e:PdkEvent):void		{			_controller.trace("Received OnLoadRelease or OnLoadReleaseUrl", "SamplePlugIn", Debug.INFO);			var release:Release = e.data as Release;			if (release.categories != null)			{				for (var i:int = 0; i < release.categories.length; i++)				{					var category:CategoryInfo = release.categories[i] as CategoryInfo;					_controller.trace("Categories[" + i + "] is " + category, "SamplePlugIn", Debug.INFO);				}			}					}				// This event fires three times per second		private function mediaPlaying(e:PdkEvent):void		{			var time:TimeObject = e.data as TimeObject;			var totalMills:int = time.currentTimeAggregate;						var timeString:String = PdkStringUtils.millisecsToStr(totalMills);			if (_bitrate > 0)			{				timeString += " (" + _bitrate + "k)";			}						// Call the write function in SampleOverlay.swf.			if (subPlugin)			{				subPlugin.write(timeString);			}							// In your subPlugin you can expose any function you'd like on the main timeline.			// Make sure you set Security.allowDomain("*"); (wildcard or some set of specific urls) 			// so that the functions can be called on the subPlugin.						/*			* this stuff is to test the getContentArea function 			* and the associated event			*/						/*if (!_clip || !_toResize) return;			_toResize = false;						var rect:Rectangle = _controller.getContentArea();			_controller.trace("getContentArea reports x: " + rect.x + ", y: " + rect.y + ", width: " + rect.width + ", height: " + rect.height, "SamplePlugin", Debug.INFO);						if (_clip.isAd) {				_controller.trace("Setting MediaArea to half", "SamplePlugIn", Debug.INFO);				(_controller as IPlayerController).setMediaPadding(new Padding(0, 0, 0, 400)); //.setMediaArea(_playerRect);			}			else {				_controller.trace("Setting MediaArea to full", "SamplePlugIn", Debug.INFO);				(_controller as IPlayerController).setMediaPadding(new Padding(0, 0, 0, 0)); //.setMediaArea(_playerRect);			}						_controller.addEventListener(PlayerEvent.onContentAreaChanged, contentAreaChanged);*/		}				private function contentAreaChanged(pev:PlayerEvent):void		{			var rect:Rectangle = pev.data as Rectangle;						_controller.trace("onContentAreaChanged reports x: " + rect.x + ", y: " + rect.y + ", width: " + rect.width + ", height: " + rect.height, "SamplePlugin", Debug.INFO);		}				// This event fires whenever the size of the overlay area changes		private function overlayAreaChanged(e:PlayerEvent):void		{			_controller.trace("Received OnOverlayAreaChanged", "SamplePlugIn", Debug.INFO);			centerPlugin(false, e.data as Rectangle);		}				// This event fires when a playlist ends.		private function releaseEnd(e:PdkEvent):void		{			_controller.trace("Received OnReleaseEnd", "SamplePlugIn", Debug.INFO);			subPlugin.write(_welcome);		}				// This event fires when a clip pauses.		private function onPause(e:PdkEvent):void		{			_controller.trace("Received OnPause", "SamplePlugIn", Debug.INFO);			_isPaused = true;		}				// This event fires when a clip resumes. 		private function onUnpause(e:PdkEvent):void		{			_controller.trace("Received OnUnpause", "SamplePlugIn", Debug.INFO);			_isPaused = false;		}				// This event fires when media starts		private function onMediaStart(e:PdkEvent):void		{			_controller.trace("Received OnMediaStart", "SamplePlugIn", Debug.INFO);			var clip:Clip = e.data as Clip;			_clip = clip;			_controller.trace("Clip title is [" + clip.title + "]", "SamplePlugIn", Debug.INFO);			for (var i:int = 0; i < clip.baseClip.categories.length; i++)			{				var category:CategoryInfo = clip.baseClip.categories[i] as CategoryInfo;				_controller.trace("Categories[" + i + "] is " + category, "SamplePlugIn", Debug.INFO);			}			_toResize = true;		}				// This event fires for multi-bitrate content, whenever a stream is		// selected		public function onStreamSwitched(e:PdkEvent):void		{			_controller.trace("Received OnStreamSwitched", "SamplePlugIn", Debug.INFO);			if (e.data.oldFileInfo)			{				_controller.trace("Old bitrate was " + e.data.oldFileInfo.bitrate, "SamplePlugIn", Debug.INFO);			}			_controller.trace("New bitrate is " + e.data.newFileInfo.bitrate, "SamplePlugIn", Debug.INFO);			_bitrate = e.data.newFileInfo.bitrate / 1000;		}						// This interface function can called by subPlugin, 		// and we then pass the action to the controller.		public function pause():void		{			var	doPause:Boolean = !_isPaused;//toggle the pause			_controller.pause(doPause);		}				// The subPlugin will always be loaded into position 0,0, 		// so if the subPlugin has graphics you'll need to 		// size and position it correctly to fit the current video area. 		private function centerPlugin(isFullScreen:Boolean, dimensions:Rectangle = null):void		{			var x:int;var y:int;var w:int;var h:int;			if (isFullScreen)			{				x = 0;				y = 0;				w = this.stage.width;				h = this.stage.height;			}			else			{				// Get the current available space for the overlay 				if (!dimensions) dimensions = _controller.getOverlayArea();				x = dimensions.x;				y = dimensions.y;				w = dimensions.width;				h = dimensions.height;			}			_controller.trace("Setting plug-in size to [" + w + "x" + h + "], positioned at [" + x + ", " + y + "]", "SamplePlugin", Debug.INFO);						// Tell the subPlugin to move and resize.			if (subPlugin)			{ 				subPlugin.center(x, y, w, h);			}		}			}}