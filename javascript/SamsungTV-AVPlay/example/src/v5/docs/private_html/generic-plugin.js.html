
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: generic-plugin.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles.css">
</head>

<body>

    <div id="main">

        <h1 class="page-title">Source: generic-plugin.js</h1>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 * Youbora API
 * Copyright NicePopleAtWork &lt;http://nicepeopleatwork.com/>
 */

/**
 * This class is the generic plugin from which specifics plugins will extend.
 * Internally, it coordinates a number of inner components like AdsApi, VideoApi, Communications, Chrono, ResourceParser, Resumer, ConcurrencyChecker...
 *
 * @class Generic
 * @since  5.1
 * @memberof $YB.plugins
 */
$YB.plugins.Generic = function() {};

$YB.plugins.Generic.prototype = {
    /** Name and platform of the plugin.*/
    pluginName: 'GENERIC',
    /** Version of the plugin. ie: 5.1.0-name */
    pluginVersion: '5.1.0-GENERIC',

    /** Unique identifier of the player, usually asociated with the ID of the tag. */
    playerId: 'generic',
    /** Reference to the player tag */
    player: undefined,
    /** Reference to the video/object tag, could be the same as the player. */
    tag: undefined,

    /** Flag when Start has been sent. */
    isStartSent: false,
    /** Flag when Join has been sent. */
    isJoinSent: false,
    /** Flag when Player is paused. */
    isPaused: false,
    /** Flag when Player is seeking. */
    isSeeking: false,
    /** Flag when Player is buffering. */
    isBuffering: false,
    /** Flag when there are ads showing. */
    isShowingAds: false,

    /** Instance of {$YB.data.Options}. Each playerId will have the same data object. If two or more plugins share playerId, they will also share data object. */
    data: undefined,
    /** An instance of {@link $YB.api.Info}. */
    infoApi: undefined,
    /** An instance of {@link $YB.api.Video}. */
    videoApi: undefined,
    /** An instance of {@link $YB.api.Ping}. */
    pingApi: undefined,
    /** An instance of {@link $YB.comm.Communication}. */
    comm: undefined,
    /** An instance inherited from  {@link $YB.adnalyzers.Generic}. */
    adnalyzer: undefined,

    /** An instance of {@link $YB.services.Resource}. */
    resourceParser: undefined,
    /** An instance of {@link $YB.services.Concurrency}. */
    concurrencyService: undefined,
    /** An instance of {@link $YB.services.Resume}. */
    resumeService: undefined,
    /** An instance of {@link $YB.services.Smartswitch}. */
    smartswitchService: undefined
};

/**
 * Instantiates the plugin libraries.
 *
 * @param {(string|object)} player Either the player object or the unique identifier of the player, usually asociated with the ID tag of the DOM.
 * @param {Object} [options] {@link $YB.data.Options |Youbora Data} initial values.
 * @return {Object} Returns the player object.
 */
$YB.plugins.Generic.prototype.init = function(player, options) {
    try {
        $YB.notice("Plugin " + this.pluginVersion + " (with YouboraJS " + $YB.version + ") is ready.");

        if (typeof player == "string") {
            this.playerId = player;
            this.player = document.getElementById(player);
        } else {
            this.player = player;
            if (player &amp;&amp; player.id) {
                this.playerId = player.id;
            }
        }

        // Save reference of the tag. If it is different, specific plugins have to overwrite it.
        this.tag = this.player;

        // Instantiate Objects
        this.data = new $YB.data.Options(options);
        this.infoApi = new $YB.api.Info(this);
        this.videoApi = new $YB.api.Video(this);
        this.pingApi = new $YB.api.Ping(this);
        this.comm = new $YB.comm.Communication(this);

        // Instantiate Services
        this.resourceParser = new $YB.services.ResourceParser(this);
        if (this.data.concurrencyConfig.enabled) {
            if ($YB.services.Concurrency) {
                this.concurrency = new $YB.services.Concurrency(this);
            } else {
                $YB.warning("Concurrecy Service is enabled but library was not found. Try to include 'services.js'.")
            }
        }
        if (this.data.resumeConfig.enabled) {
            if ($YB.services.Resume) {
                this.resume = new $YB.services.Resume(this);
            } else {
                $YB.warning("Resume Service is enabled but library was not found. Try to include 'services.js'.")
            }
        }
        if (this.data.smartswitchConfig.enabled) {
            if ($YB.services.Smartswitch) {
                this.smartswitch = new $YB.services.Smartswitch(this);
            } else {
                $YB.warning("Smartswitch Service is enabled but library was not found. Try to include 'services.js'.")
            }
        }

        // Send /data request
        this.comm.requestData({
            system: this.data.accountCode,
            pluginVersion: this.pluginVersion,
            targetDevice: this.pluginName,
            live: this.data.media.isLive
        });

        return this.player;

    } catch (err) {
        $YB.error(err);
        return null;
    }
}

/**
 * Starts Nicebuffer in video APIs.
 */
$YB.plugins.Generic.prototype.startAutobuffer = function() {
    if (this.data.enableNiceBuffer) {
        this.videoApi.buffer.autostart = true;
    }
};

/**
 * This function must be called when a new video starts loading.
 * @see $YB.api.Video#sendStart
 */
$YB.plugins.Generic.prototype.playHandler = function(options) {
    try {
        if (!this.isStartSent) {
            this.setOptions(options);
            this.videoApi.sendStart();
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when video changes in a playlist.
 * @see $YB.api.Video#sendStart
 */
$YB.plugins.Generic.prototype.videoChangeHandler = function(options) {
    try {
        this.setOptions(options);
        this.videoApi.sendStart();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video starts playing for the first time. If playingHandler is used, this function is not needed.
 * @see $YB.api.Video#sendJoin
 */
$YB.plugins.Generic.prototype.joinHandler = function() {
    try {
        this.videoApi.sendJoin();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video starts playing (either for the first time or arfter a pause, seek or buffer).
 * @see $YB.api.Video#sendStart
 * @see $YB.api.Video#sendResume
 * @see $YB.api.Video#sendSeekEnd
 * @see $YB.api.Video#sendBufferEnd
 */
$YB.plugins.Generic.prototype.playingHandler = function() {
    try {
        if (this.isStartSent) {
            if (!this.isJoinSent) {
                this.videoApi.sendJoin();
            } else if (this.isSeeking &amp;&amp; this.isPaused) {
                this.videoApi.sendSeekEnd();
                this.videoApi.sendResume();
            } else if (this.isSeeking) {
                this.videoApi.sendSeekEnd();
            } else if (this.isBuffering) {
                this.videoApi.sendBufferEnd();
            } else if (this.isPaused) {
                this.videoApi.sendResume();
            }
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video is paused.
 * @see $YB.api.Video#sendPause
 */
$YB.plugins.Generic.prototype.pauseHandler = function() {
    try {
        this.videoApi.sendPause();
    } catch (err) {
        $YB.error(err);
    }
};


/**
 * This function must be called when a button of pause/resume is pressed.
 * @see $YB.api.Video#sendPause
 * @see $YB.api.Video#sendResume
 */
$YB.plugins.Generic.prototype.pauseToggleHandler = function() {
    try {
        if (this.isPaused) {
            this.videoApi.sendResume();
        } else {
            this.videoApi.sendPause();
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video is resumed from a pause. If playingHandler is used, this function is not needed.
 * @see $YB.api.Video#sendResume
 */
$YB.plugins.Generic.prototype.resumeHandler = function() {
    try {
        this.videoApi.sendResume();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video has ended.
 * @see $YB.api.Video#sendStop
 */
$YB.plugins.Generic.prototype.endedHandler = function() {
    try {
        this.videoApi.sendStop();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video has been stoped.
 * @see $YB.api.Video#sendStop
 */
$YB.plugins.Generic.prototype.stopHandler = function() {
    try {
        this.videoApi.sendStop();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video throws an error.
 * In case you could not find a code, send only the message.
 * In case you can not get an error message you should create your own message.
 * @see $YB.api.Video#sendError
 * @param code Error code
 * @param msg Error message.
 */
$YB.plugins.Generic.prototype.errorHandler = function(code, msg) {
    try {
        if (typeof code == "undefined") {
            code = 0;
        }
        msg = msg || code || 'Unknown error';

        this.videoApi.sendError({
            errorCode: code,
            msg: msg
        });
        //this.videoApi.sendStop();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video starts a seek.
 * @see $YB.api.Video#sendSeekStart
 */
$YB.plugins.Generic.prototype.seekingHandler = function() {
    try {
        if (this.isBuffering) {
            this.videoApi.chrono.seek.startTime = this.videoApi.chrono.buffer.startTime;
            this.videoApi.chrono.seek.lastTime = 0;

            this.videoApi.chrono.buffer.stop();
            this.isBuffering = false;
            this.isSeeking = true;
        } else {
            this.videoApi.sendSeekStart();
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video ends Seeking. If playingHandler is used, this function is not needed.
 * @see $YB.api.Video#sendSeekEnd
 * @memberof Generic
 */
$YB.plugins.Generic.prototype.seekedHandler = function() {
    try {
        this.videoApi.sendSeekEnd();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video starts a buffer underrun.
 * @see $YB.api.Video#sendBufferStart
 */
$YB.plugins.Generic.prototype.bufferingHandler = function() {
    try {
        if (!this.isSeeking) {
            this.videoApi.sendBufferStart();
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when the video ends buffering. If playingHandler is used, this function is not needed.
 * @see $YB.api.Video#sendBufferEnd
 */
$YB.plugins.Generic.prototype.bufferedHandler = function() {
    try {
        if (this.isStartSent) {
            if (!this.isJoinSent) {
                this.videoApi.sendJoin();
            } else if (this.isSeeking) {
                this.videoApi.sendSeekEnd();
            } else if (this.isBuffering) {
                this.videoApi.sendBufferEnd();
            }
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when an ad starts. If you are using adnalyzer modules, this function won't work.
 * @see $YB.api.Video#sendSeekStart
 */
$YB.plugins.Generic.prototype.genericAdStartHandler = function() {
    try {
        this.videoApi.sendGenericAdStart();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * This function must be called when an ad ends. If you are using adnalyzer modules, this function won't work.
 * @see $YB.api.Video#sendSeekEnd
 * @memberof Generic
 */
$YB.plugins.Generic.prototype.genericAdEndHandler = function() {
    try {
        this.videoApi.sendGenericAdEnd();
    } catch (err) {
        $YB.error(err);
    }
};


/**
 * Changes the $YB.data.Options options.
 * @see $YB.data.Options#setOptions
 */
$YB.plugins.Generic.prototype.setOptions = function(options) {
    try {
        this.data.setOptions(options);
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Returns $YB.data.Options options.
 * @returns $YB.data.Options
 * @see $YB.data.Options
 */
$YB.plugins.Generic.prototype.getOptions = function() {
    try {
        return this.data || {};
    } catch (err) {
        $YB.error(err);
        return {};
    }
};


/**
 * Override this function to return resource.
 * @return {string} "unknown".
 */
$YB.plugins.Generic.prototype.getResource = function() {
    return "unknown";
};

/**
 * Override this function to return resource.
 * @return {string} 0.
 */
$YB.plugins.Generic.prototype.getPlayhead = function() {
    return 0;
};

/**
 * Override this function to return resource.
 * @return {number} 0.
 */
$YB.plugins.Generic.prototype.getMediaDuration = function() {
    return 0;
};

/**
 * Override this function to return resource.
 * @return {bool} false.
 */
$YB.plugins.Generic.prototype.getIsLive = function() {
    return false;
};

/**
 * Override this function to return resource.
 * @return {string} "".
 */
$YB.plugins.Generic.prototype.getRendition = function() {
    return null;
};

/**
 * Override this function to return bitrate.
 * @return {number} -1.
 */
$YB.plugins.Generic.prototype.getBitrate = function() {
    return -1;
};

/**
 * Override this function to return throughput.
 * @return {number} -1.
 */
$YB.plugins.Generic.prototype.getThroughput = function() {
    return -1;
};

/**
 * Override this function to return player version.
 * @return {string} "".
 */
$YB.plugins.Generic.prototype.getPlayerVersion = function() {
    return null;
};

/**
 * Override this function to return totalbytes.
 * @return {number} null.
 */
$YB.plugins.Generic.prototype.getTotalBytes = function() {
    return null;
};

/**
 * Override this function to return media title.
 * @return {string} "".
 */
$YB.plugins.Generic.prototype.getTitle = function() {
    return null;
};
</code></pre>
        </article>
    </section>




    </div>

    <nav>
        <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="$YB.adnalyzers.Generic.html">$YB.adnalyzers.Generic</a></li><li><a href="$YB.api.Ads.html">$YB.api.Ads</a></li><li><a href="$YB.api.Info.html">$YB.api.Info</a></li><li><a href="$YB.api.Ping.html">$YB.api.Ping</a></li><li><a href="$YB.api.Video.html">$YB.api.Video</a></li><li><a href="$YB.comm.AjaxRequest.html">$YB.comm.AjaxRequest</a></li><li><a href="$YB.comm.Communication.html">$YB.comm.Communication</a></li><li><a href="$YB.data.Options.html">$YB.data.Options</a></li><li><a href="$YB.plugins.Generic.html">$YB.plugins.Generic</a></li><li><a href="$YB.services.ResourceParser.html">$YB.services.ResourceParser</a></li><li><a href="$YB.utils.Buffer.html">$YB.utils.Buffer</a></li><li><a href="$YB.utils.Chrono.html">$YB.utils.Chrono</a></li></ul><h3>Namespaces</h3><ul><li><a href="$YB.html">$YB</a></li><li><a href="$YB.adnalyzers.html">$YB.adnalyzers</a></li><li><a href="$YB.api.html">$YB.api</a></li><li><a href="$YB.comm.html">$YB.comm</a></li><li><a href="$YB.data.html">$YB.data</a></li><li><a href="$YB.plugins.html">$YB.plugins</a></li><li><a href="$YB.services.html">$YB.services</a></li><li><a href="$YB.utils.html">$YB.utils</a></li></ul>
    </nav>

    <div class="clear"></div>
    <footer>
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Apr 22 2016 09:34:52 GMT+0200 (CEST)
    </footer>

    <script> prettyPrint(); </script>
    <script src="scripts/linenumber.js"> </script>
</body>
</html>