
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: service-resource.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles.css">
</head>

<body>

    <div id="main">

        <h1 class="page-title">Source: service-resource.js</h1>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 * Youbora services.ResourceParser
 * Copyright NicePopleAtWork &lt;http://nicepeopleatwork.com/>
 */

/**
 * Youbora services.ResourceParser will parse the precise CDN of the resource if data.parseHLS or data.parseCDNNodeHost are true.
 * CDNs will be parsed in the order defined in {@link $YB.services.ResourceParser.cdnsAvailable}, modify context list to modify order.
 *
 * @class
 * @memberof $YB
 * @param {$YB.plugins.Generic} plugin The plugin from where it was called.

 */
$YB.services.ResourceParser = function(plugin) {
    try {
        this.plugin = plugin;
        this.parseTimeout = null;

        /** Final resource parsed.
         * @var {string}
         * @readonly
         */
        this.realResource = '';

        /** Node Host name after parsing it.
         * @var {string}
         * @readonly
         */
        this.nodeHost = undefined;

        /** Code of the Node Host type after parsing it.
         * @var {number}
         * @readonly
         */
        this.nodeType = undefined;

        this.cdnRequests = {};
        this.cdns = $YB.services.ResourceParser.cdnsEnabled.slice();
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Starts the process if either parseHLS or parseCDNNodeHost are active. The process is aborted automatically after 3 seconds.
 */
$YB.services.ResourceParser.prototype.init = function() {
    try {
        // Reinit
        if (this.realResource) {
            this.clear();
        }

        // Add Preloader
        this.plugin.comm.addPreloader('services.ResourceParser');

        // Abort operation after 3s
        var context = this;
        this.parseTimeout = setTimeout(function() {
            if ('services.ResourceParser' in context.plugin.comm.preloaders) {
                context.realResource = context.plugin.infoApi.getResource();
                context.plugin.comm.removePreloader('services.ResourceParser');
                $YB.warn('ResourceParser has exceded the maximum execution time (3s) and will be aborted.');
            }
        }, 3000);

        // Start processing
        this.realResource = this.plugin.infoApi.getResource();
        if (this.plugin.data.parseHLS) {
            this._parseRealResourceAsync(this.realResource);
        } else {
            this._parseCDNAsync();
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Clear the info fetched by services.ResourceParser. Should be called after a stop is sent.
 */
$YB.services.ResourceParser.prototype.clear = function() {
    this.realResource = '';
    this.nodeHost = undefined;
    this.nodeType = undefined;
    this.cdnRequests = {};
    this.cdns = $YB.services.ResourceParser.cdnsEnabled.slice();
};

/**
 * Parses resource, if it is an HLS .m3u8 file, it recursively parses its info until .ts or .mp4 is found.
 *
 * @private
 * @param {string} resource path to the resource.
 */
$YB.services.ResourceParser.prototype._parseRealResourceAsync = function(resource, parentResource) {
    try {
        var matches = /(\S*?(\.m3u8|\.m3u|\.ts|\.mp4)(\?\S*|\n|\r|$))/i.exec(resource); //get first line ending in .m3u8, .m3u, .mp4 or .ts
        if (matches !== null) {
            var res = matches[1].trim();
            if (res.indexOf('http') !== 0) { // Does not start with http add parentResource relative route.
                res = parentResource.slice(0, parentResource.lastIndexOf('/')) + "/" + res;
            }
            if (matches[2] == '.m3u8' || matches[2] == '.m3u') { // It is m3u8 or m3u...
                var context = this;
                new $YB.comm.AjaxRequest(res).load(function() {
                        context._parseRealResourceAsync(this.responseText, res); //In this plugin, this referes to the XHR.
                    }).error(function() {
                        context._parseCDNAsync();
                    })
                    .send();
            } else { // It is mp4 or ts...
                this.realResource = res;
                this._parseCDNAsync();
            }
        } else {
            this._parseCDNAsync();
        }
    } catch (err) {
        $YB.error(err);
        this._parseCDNAsync();
    }
};


/** List of CDNs in order for execution. Can be modified to alter the order/list of CDNs available.
 * CDNs context share headers will share request, saving resources.
 */
$YB.services.ResourceParser.cdnsEnabled = ['Level3', 'Akamai', 'Highwinds', 'Fastly'];

/** List of CDNs configuration. */
$YB.services.ResourceParser.cdnsAvailable = {
    Level3: {
        parsers: [{
            type: 'host+type',
            name: 'X-WR-DIAG',
            regex: /Host:(.+)\sType:(.+)/
        }],
        headers: {
            'X-WR-DIAG': 'host'
        }
    },
    Akamai: {
        parsers: [{
            type: 'host+type',
            name: 'X-Cache',
            regex: /(.+)\sfrom\s.+\(.+\/(.+)\).+/
        }]
    },
    Highwinds: {
        parsers: [{
            type: 'host+type',
            name: 'X-HW',
            regex: /.+,[0-9]+\.(.+)\.(.+)/
        }]
    },
    Fastly: {
        parsers: [{
            type: 'host',
            name: 'X-Served-By',
            regex: /([^,\s]+)$/
        }, {
            type: 'type',
            name: 'X-Cache',
            regex: /([^,\s]+)$/
        }]
    }
};

/**
 * Starts the parsing of CDN Nodes.
 * @private
 */
$YB.services.ResourceParser.prototype._parseCDNAsync = function() {
    try {
        if (this.plugin.data.parseCDNNodeHost) {
            if (this.cdns.length > 0 &amp;&amp; !this.nodeHost) { // if there's CDN remaining in the pool and host has not been retrieved...
                var cdn = this.cdns.shift();
                if (typeof $YB.services.ResourceParser.cdnsAvailable[cdn] != 'undefined') {

                    var config = $YB.services.ResourceParser.cdnsAvailable[cdn],
                        headers = JSON.stringify(config.headers);

                    if (this.cdnRequests.hasOwnProperty(headers)) {
                        this._parseNode(config.parsers, this.cdnRequests[headers]);
                    } else {
                        var context = this;

                        var ajax = new $YB.comm.AjaxRequest(this.realResource, '', '', {
                            method: 'HEAD',
                            maxRetries: 0,
                            requestHeaders: config.headers
                        });

                        ajax.load(function() {
                            context.cdnRequests[headers] = ajax.getXHR();
                            context._parseNode(config.parsers, ajax.getXHR());
                        });

                        ajax.error(function() {
                            context._parseCDNAsync();
                        });

                        ajax.send();
                    }
                } else {
                    this._parseCDNAsync();
                }
            } else {
                this.plugin.comm.removePreloader('services.ResourceParser');
            }
        } else {
            this.plugin.comm.removePreloader('services.ResourceParser');
        }
    } catch (err) {
        $YB.error(err);
    }
};

$YB.services.ResourceParser.prototype._parseNode = function(parsers, response) {
    try {
        for (var key in parsers) {
            var header = response.getResponseHeader(parsers[key].name); // May throw error since headers will not always be available.
            if (header !== null) {
                var match = parsers[key].regex.exec(header);

                if (match !== null) {
                    switch (parsers[key].type) {
                        case 'host':
                            this.nodeHost = match[1];
                            break;
                        case 'type':
                            this.nodeType = this._parseNodeType(match[1]);
                            break;
                        case 'host+type':
                            this.nodeHost = match[1];
                            this.nodeType = this._parseNodeType(match[2]);
                            break;
                        case 'type+host':
                            this.nodeType = this._parseNodeType(match[1]);
                            this.nodeHost = match[2];
                            break;
                    }
                } else {
                    this._parseCDNAsync();
                    return;
                }
            } else {
                this._parseCDNAsync();
                return;
            }
        }

        this._parseCDNAsync();
    } catch (err) {
        $YB.error(err);
        this._parseCDNAsync();
    }
};

$YB.services.ResourceParser.prototype._parseNodeType = function(type) {
    try {
        switch (type) {
            case 'TCP_HIT':
            case 'HIT':
            case 'c':
                return 1;
            case 'TCP_MISS':
            case 'MISS':
            case 'p':
                return 2;
            case 'TCP_MEM_HIT':
                return 3;
            case 'TCP_IMS_HIT':
                return 4;
            default:
                return 0;
        }
    } catch (err) {
        $YB.error(err);
        return 0;
    }
};
</code></pre>
        </article>
    </section>




    </div>

    <nav>
        <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="$YB.adnalyzers.Generic.html">$YB.adnalyzers.Generic</a></li><li><a href="$YB.api.Ads.html">$YB.api.Ads</a></li><li><a href="$YB.api.Info.html">$YB.api.Info</a></li><li><a href="$YB.api.Ping.html">$YB.api.Ping</a></li><li><a href="$YB.api.Video.html">$YB.api.Video</a></li><li><a href="$YB.comm.AjaxRequest.html">$YB.comm.AjaxRequest</a></li><li><a href="$YB.comm.Communication.html">$YB.comm.Communication</a></li><li><a href="$YB.data.Options.html">$YB.data.Options</a></li><li><a href="$YB.plugins.Generic.html">$YB.plugins.Generic</a></li><li><a href="$YB.services.ResourceParser.html">$YB.services.ResourceParser</a></li><li><a href="$YB.utils.Buffer.html">$YB.utils.Buffer</a></li><li><a href="$YB.utils.Chrono.html">$YB.utils.Chrono</a></li></ul><h3>Namespaces</h3><ul><li><a href="$YB.html">$YB</a></li><li><a href="$YB.adnalyzers.html">$YB.adnalyzers</a></li><li><a href="$YB.api.html">$YB.api</a></li><li><a href="$YB.comm.html">$YB.comm</a></li><li><a href="$YB.data.html">$YB.data</a></li><li><a href="$YB.plugins.html">$YB.plugins</a></li><li><a href="$YB.services.html">$YB.services</a></li><li><a href="$YB.utils.html">$YB.utils</a></li></ul>
    </nav>

    <div class="clear"></div>
    <footer>
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Apr 22 2016 09:34:52 GMT+0200 (CEST)
    </footer>

    <script> prettyPrint(); </script>
    <script src="scripts/linenumber.js"> </script>
</body>
</html>