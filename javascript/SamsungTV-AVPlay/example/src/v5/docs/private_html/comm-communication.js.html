
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: comm-communication.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles.css">
</head>

<body>

    <div id="main">

        <h1 class="page-title">Source: comm-communication.js</h1>

        



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @license
 * Youbora Communication
 * Copyright NicePopleAtWork &lt;http://nicepeopleatwork.com/>
 */

/**
 * Youbora Communication implements the last abstraction layer against NQS requests.
 * Internally, Communication implements an array of $YB.comm.AjaxRequest objects, executing one after another.
 * All requests will be blocked until a first /data call is made, before context, any request sent will be queued.
 *
 * @class
 * @private
 * @memberof $YB
 * @param {$YB.plugins.Generic} plugin The plugin from where it was called.
 */
$YB.comm.Communication = function(plugin) {
    try {
        /** Reference to the {@link $YB.plugins.Generic|plugin} from where it was called. */
        this.plugin = plugin;

        /** The host of the requests. Got from {@link $YB.data.Options|this.plugin.data.service}. */
        this.host = plugin.data.service;

        /** Time between pings defined by FastData. In seconds. */
        this.pingTime = 5;

        /** Prefix code character. L = Live, V = Vod, U = Unknown. */
        this.prefix = 'U';

        /** Communication code from the FastData request.*/
        this.code = '';

        /** Number of the view. Every /start call will add 1 to context number. Starts at -1 (first view will be 0). */
        this.view = -1;

        /** Array of strings, only when the array is empty the request Queues will begin sending. */
        this.preloaders = [];

        this._requests = {}; // Queue of requests, indexed by view code. Format: {U_code_0: [request1, request2], U_code_1: []}

        this.addPreloader('FastData');
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * The code of the view.
 * @return {string} The code
 */
$YB.comm.Communication.prototype.getViewCode = function() {
    if (this.code) {
        return this.prefix + this.code + '_' + this.view;
    } else {
        return 'nocode';
    }
};

/**
 * Creates a new view code.
 * @param {bool} isLive Determines if the view code should start with V, L or U.
 * @return {string} The code of the new view.
 */
$YB.comm.Communication.prototype.nextView = function(isLive) {
    this.view++;

    if (isLive === true) {
        this.prefix = "L";
    } else if (isLive === false) {
        this.prefix = "V";
    } else {
        this.prefix = "U";
    }

    return this.getViewCode();
};

/**
 * Sends '/data' request. This has to be the first request and all other request will wait till we got a callback from this.
 *
 * @param {Object} params An object of parameters sent with the request.
 * @param {string} params.params.system System code.
 * @param {string} params.pluginVersion 3.x.x-&lt;pluginName>
 * @param {boolean} [params.live] true if the content is life. False if VOD. Do not send if unknown.
 * @param {function} [callback] The defined load callback to the ajaxRequest
 */
$YB.comm.Communication.prototype.requestData = function(params, callback) {
    try {
        params = params || {};
        params.outputformat = 'jsonp';
        delete params.code;
        var context = this,
            ajax = new $YB.comm.AjaxRequest(this._parseServiceHost(this.host), '/data', params);

        ajax.load(function() {
            context.receiveData(ajax);
        });
        ajax.load(callback);

        ajax.send();

        $YB.notice("Request: NQS /data " + params.system, 'darkgreen');
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Callback function to parse '/data' response.
 */
$YB.comm.Communication.prototype.receiveData = function(ajax) {
    try {
        var response = ajax.getXHR().response,
            msg = JSON.parse(response.slice(response.indexOf('(') + 1, response.lastIndexOf(')'))),
            host = msg.q.h, // Host
            code = msg.q.c, // Code
            pt = msg.q.pt, // Ping time interval in seconds
            //tc: msg.q.tc, // Transaction code
            //t: msg.q.t // Test
            balancer = msg.q.b; // 1 = Balancer enabled

        if (host.length > 0 &amp;&amp;
            code.length > 0 &amp;&amp;
            pt.length > 0 &amp;&amp;
            balancer.length > 0
        ) {
            this.prefix = code.slice(0, 1);
            this.code = code.slice(1);
            this.host = host;
            this.pingTime = pt;
            this.plugin.pingApi.interval = this.pingTime * 1000;
            this.balancerEnabled = balancer;

            $YB.notice('FastData \'' + code + '\' is ready.', 'darkgreen');

            // Move requests from 'nocode' to the proper queue
            if (this._requests.nocode &amp;&amp; this._requests.nocode.length > 0) {
                this._requests[this.getViewCode()] = this._requests.nocode;
                delete this._requests.nocode;
            }

            // Everything is ok, start sending requests
            this.removePreloader('FastData');
        } else {
            $YB.error('Error: FastData response is wrong.');
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Sends a generic request. All the specific functions use this method.
 * Will automatically report an error if the request gives Error.
 *
 * @param {string} service A string with the service to be called. ie: 'nqs.nice264.com/data', '/joinTime'...
 * @param {(Object|string)} [params] Either a object or an uri-formated string with the args of the call.
 * @param {function} [callback] The defined load callback to the ajaxRequest
 */
$YB.comm.Communication.prototype.sendRequest = function(service, params, callback) {
    try {
        if (this.isAllowed(service)) {
            params = params || {};
            delete params.code;
            var ajax = new $YB.comm.AjaxRequest('', service, params);
            ajax.load(callback);
            this._registerRequest(ajax);
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Sends a service request.
 *
 * @param {string} service A string with the service to be called. ie: 'pc.youbora.com/cping/'
 * @param {(Object|string)} [params] Either a object or an uri-formated string with the args of the call.
 * @param {function} [callback] The defined load callback to the ajaxRequest
 */
$YB.comm.Communication.prototype.sendService = function(service, params, callback) {
    try {
        var ajax = new $YB.comm.AjaxRequest(this._parseServiceHost(service), '', params);
        ajax.load(callback);
        this._registerRequest(ajax);
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Returns if this kind of analytic is allowed (enableAnalytics must be true and the service shall not be in disabledRequests).
 * @param {string} srv Name of the service. ie: '/seek'.
 * @return {bool} True if the analytic is allowed, false otherwise.
 */
$YB.comm.Communication.prototype.isAllowed = function(srv) {
    return (this.plugin.data.enableAnalytics &amp;&amp; !(srv in this.plugin.data.disabledRequests));
};

/**
 * Adds a preloader to the queue. While this queue is not empty, all requests will be stoped.
 * Remember to call removePreloader to unblock the main queue
 *
 * @param {string} key Unique identifier of the blocker. ie: 'CDNParser'.
 */
$YB.comm.Communication.prototype.addPreloader = function(key) {
    try {
        this.preloaders.push(key);
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Removes a preloader. If it was the last preloader, all requests queued will be sent.
 *
 * @param {string} key Unique identifier of the blocker. ie: 'CDNParser'.
 */
$YB.comm.Communication.prototype.removePreloader = function(key) {
    try {
        var pos = this.preloaders.indexOf(key);
        if (pos !== -1) {
            this.preloaders.splice(pos, 1);

            if (this.preloaders.length === 0) { // if there is no more preloaders blocking the queue...
                var ajax;
                for (var k in this._requests) {
                    while (ajax = this._requests[k].shift()) {
                        ajax.setParam('code', k); //if no code, use last

                        if (!ajax.host) {
                            ajax.host = this._parseServiceHost(this.host);
                        }

                        // Replace resource parser discoveries
                        if (typeof ajax.params.resource != "undefined" &amp;&amp; this.plugin.resourceParser.realResource) {
                            ajax.params.resource = this.plugin.resourceParser.realResource; // If realresource was fetched, use it.
                        }
                        if (typeof ajax.params.nodeHost != "undefined" &amp;&amp; this.plugin.resourceParser.nodeHost) {
                            ajax.params.nodeHost = this.plugin.resourceParser.nodeHost;
                            ajax.params.nodeType = this.plugin.resourceParser.nodeType;
                        }

                        ajax.send();
                    }
                }
            }
        } else {
            $YB.warn('Warning: trying to remove unexisting preloader \'' + key + '\'.');
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Adds an AjaxRequest to the queue of requests.
 *
 * @private
 * @param request The AjaxRequest to be queued.
 * @returns Returns a pointer to the AjaxRequest.
 */
$YB.comm.Communication.prototype._registerRequest = function(request) {
    try {

        if (typeof this._requests[this.getViewCode()] == 'undefined') {
            this._requests[this.getViewCode()] = [];
        }

        request.setParam('timemark', new Date().getTime());

        this._requests[this.getViewCode()].push(request);
        this._sendRequests();

        return request;
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Execute pending requests in the queue.
 * @private
 */
$YB.comm.Communication.prototype._sendRequests = function() {
    try {
        if (this.preloaders.length === 0) { // if data has been retreived and there is no preloader blocking the queue...
            var ajax;
            for (var k in this._requests) {
                while (ajax = this._requests[k].shift()) {
                    ajax.setParam('code', k); // add code
                    if (!ajax.host) {
                        ajax.host = this._parseServiceHost(this.host);
                    }

                    ajax.send();
                }
            }
        }
    } catch (err) {
        $YB.error(err);
    }
};

/**
 * Determine the service host protocol. ie: [http[s]:]//nqs.nice264.com
 * Determines protocol by data.httpSecure.
 *
 * @private
 * @param url URL of the service.
 * @return Return the complete service URL.
 */
$YB.comm.Communication.prototype._parseServiceHost = function(url) {
    try {
        // Service
        if (url.indexOf('//') === 0) {
            url = url.slice(2);
        } else if (url.indexOf('http://') === 0) {
            url = url.slice(7);
        } else if (url.indexOf('https://') === 0) {
            url = url.slice(8);
        }

        if (this.plugin.data.httpSecure === true) {
            url = 'https://' + url;
        } else if (window.location.protocol.indexOf('http') === 0) {
            url = '//' + url;
        } else {
            url = 'http://' + url;
        }

        return url;

    } catch (err) {
        $YB.error(err);
        return 'http://localhost';
    }
};
</code></pre>
        </article>
    </section>




    </div>

    <nav>
        <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="$YB.adnalyzers.Generic.html">$YB.adnalyzers.Generic</a></li><li><a href="$YB.api.Ads.html">$YB.api.Ads</a></li><li><a href="$YB.api.Info.html">$YB.api.Info</a></li><li><a href="$YB.api.Ping.html">$YB.api.Ping</a></li><li><a href="$YB.api.Video.html">$YB.api.Video</a></li><li><a href="$YB.comm.AjaxRequest.html">$YB.comm.AjaxRequest</a></li><li><a href="$YB.comm.Communication.html">$YB.comm.Communication</a></li><li><a href="$YB.data.Options.html">$YB.data.Options</a></li><li><a href="$YB.plugins.Generic.html">$YB.plugins.Generic</a></li><li><a href="$YB.services.ResourceParser.html">$YB.services.ResourceParser</a></li><li><a href="$YB.utils.Buffer.html">$YB.utils.Buffer</a></li><li><a href="$YB.utils.Chrono.html">$YB.utils.Chrono</a></li></ul><h3>Namespaces</h3><ul><li><a href="$YB.html">$YB</a></li><li><a href="$YB.adnalyzers.html">$YB.adnalyzers</a></li><li><a href="$YB.api.html">$YB.api</a></li><li><a href="$YB.comm.html">$YB.comm</a></li><li><a href="$YB.data.html">$YB.data</a></li><li><a href="$YB.plugins.html">$YB.plugins</a></li><li><a href="$YB.services.html">$YB.services</a></li><li><a href="$YB.utils.html">$YB.utils</a></li></ul>
    </nav>

    <div class="clear"></div>
    <footer>
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Apr 22 2016 09:34:52 GMT+0200 (CEST)
    </footer>

    <script> prettyPrint(); </script>
    <script src="scripts/linenumber.js"> </script>
</body>
</html>